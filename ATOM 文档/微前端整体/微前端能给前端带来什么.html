<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div class="box_NBaWu legacy_2zXwy">
    <p>
      本文将以iHome现阶段业务前端视角出发，从中后台以及家装编辑器两大场景中，总结我们团队对微前端领域的思考。全文基于我们自研的微前端体系方案atom展开，atom是完全贴合我们自己业务设计的微前端架构体系方案，在通用能力方面后续将会与icestark融合。
    </p>\n<p>
      微前端的技术方案，目前主要阵地还是在中后台应用中，其实这也无可厚非。对于C端普遍以重后端，轻前端的场景中，很少有微前端的必要性，不过，理念还是会有很多共通点。而中后台的前端应用，尤其是ToB场景中，承载大量业务逻辑的前端应用，则很容易长成巨石应用，在几个大迭代之后，就陷入不可维护状态。与服务端的进化过程类比，个人更倾向于是服务化，而非微服务。总体来说，微前端主要是为了将复杂庞大的系统，变得精简，更易维护。
    </p>\n<p>
      <strong><em>当我们深入业务场景，不是只停留在框架的时候，我们发现微前端可以做到更多。</em></strong><br>\n<strong><em>回头来看，它也应该做到更多。</em></strong>
    </p>\n<h3>从业务开始</h3>\n<p>
      iHome的定制业务将门店、生产、配送全部打通，消费者如果需要给家里定制一个衣柜，可以在iHome业务相关的门店完成一站式服务，手淘搜索躺平智造后可以发现附近的门店(目前杭州还没有)，入会之后就会有设计师上门免费量房，并在iHome设计编辑器里完成定制衣柜的方案，用户完成交易链路后，设计方案就会给到拆审单服务商完成设计拆解，给到工厂一份可以生产的内容，最后则会有专业团队上门安装。
    </p>\n<p>在这一整条业务链路中，前端的复杂度在于两处：</p>\n<ol>\n<li>
        整个业务链路分多个独立系统(比如CRM、交易)，但是需要以完整的产品对外输出，即常见的复杂中后台场景。</li>\n<li>
        设计编辑器，一个类似IDE的专业设计软件，只有一个页面，但是聚合了大量功能点。</li>\n</ol>\n<p>
      对于第一个场景，我们在一开始选型时就确定了微前端方案，当时因为业务生长在新零售工作台，所以主要的技术框架以适配为主，同时考虑到后期必然发生的迁移，我们在子应用之上，做了适配层，适配了社区的Single-SPA框架。在这个阶段，iHome业务的微前端并没有太大的特殊性，而且由于我们的技术选型，顺利借助了新零售工作台的基础配置能力，一方面帮助他们做了技术的拓展，另一方面帮助我们自己业务快速落地。
    </p>\n<p>第一类场景，微前端的价值和架构体系需要的内容，我认为在克军老师的这篇<a
        href="https://yuque.antfin-inc.com/docs/share/8804b32d-9652-4086-895c-7a1785531244"
        target="_blank">文章</a>中，已经阐述得非常简明扼要了。同时，在看了D2上乾坤的分享，淘系ice-stark方案，厂外字节的微前端方案后，我们发现，所有微前端框架都倾向于单一微应用独占运行时，即同一时间只有一个微应用在工作。即使在克军老师给的阿里云的技术方案中，多微应用也是可行，但是并不认为是常态。
    </p>\n<p>
      对于这个观点，按照绝大部分中后台应用的视角来说，并不需要反驳。但是，如果我们真的从微前端对标的微服务来看，多应用共存才是一个常态。由于这样一个现状，甚至有一些同学会认为，微前端不应该与微服务对标，而应该用另一个更合适的词去描述。起初我们也是持有类似观点的，直到去年S2开始，我们接手了设计编辑器这个全新的应用场景后，微前端在我们这里有了不同的使命。
    </p>\n<p>
      在类编辑器的场景里，我认为，<strong>我们应该将这个前端应用看作是一个系统。</strong>还是从业务场景举例，在设计编辑器中，我们存在多个核心的业务板块：定制家具设计、硬装吊顶背景墙设计、方案实景渲染等，还有很多基础功能板块，比如拾取系统、保存加载能力等。这些板块从名字就能断定，必然是需要不同团队去维护的，功能上也是需要解耦开的。他们互相配合才能将整个编辑器运作起来。因此在技术架构上，我们需要对其做不同层次的划分，业务架构上则需要做到按领域划分。前端微应用的拆分维度，在这样一个场景里，首次真正意义上与微服务对标了起来，那就是《微服务架构设计模式》中说到的：
    </p>\n<blockquote>\n<p data-spm-anchor-id="ata.21736010.0.i1.3d2f572cp3PaE6">
        服务是一个单一的、可独立部署的软件组件，它实现了一些有用的功能</p>\n</blockquote>\n<p>
      这个场景符合了我们在类比微服务时所有的需求点，也正因如此，当我们把他们微前端化的时候，我们遇到了一些新的不得不面对的问题。</p>\n<h3>复杂微前端应用的痛点</h3>\n
    <ol>\n<li>\n<p>
          调试困难<br>\n对于传统微前端场景来说，开发某一个微应用只需要将其启动即可，在绝大部分的情况，微应用是可以独立存在的，甚至在乾坤的技术方案里，这是作为一个基础条件存在着的。但是，在编辑器场景中，有2个共识被彻底打破，第一是微应用大部分时间只有一个，第二是微应用可以独立存在。编辑器中为了完成一条业务链路，上下游微应用需要互相配合，因此，日常开发中或许只修改一个微应用，但是调试运行时中，却经常需要10几个微应用同时启动。如果按照传统的方案，我们需要先启动主应用，其次将10几个微应用依次启动，这显然是不可取的方法。
        </p>\n<p>我们在整个架构体系中，通过几个模块的协作来解决这个问题：<br>\n<span class="box_1zuEB image_2R4eW"><img
              src="https://ata2-img.oss-cn-zhangjiakou.aliyuncs.com/0de2b269d129c19434423911d2a31652.jpg"
              alt="ppt1.jpg"></span><br>\nchrome插件参考了xswitch的思路，在本地开发中，我们不再启动主应用，而是基于某一个环境的主应用，配合插件的转发能力，将对应的子应用资源转发到本地。而新开发插件是为了将整体开发体验在提升一步，在我们的工具链中，本地cli工具会基于规范，让开发同学启动N个子应用，同时提供接口将信息传递给chrome插件。在浏览器侧，插件background将会与管理后台通信，获取当前主应用的配置信息，同时合并本地启动项，从而在打开主应用页面时，无感知的将子应用代理回本地。
        </p>\n</li>\n<li>\n<p>
          公共模块<br>\n以渲染应用为例，手动灯光控制与渲染主流程会独立开发，但是必然会有一些通用的util方法，于是业务上必然会遇到一个技术选型的问题：util是一个npm包，还是一个子应用？
        </p>\n<p>
          在多子应用前提下，公共模块即使不考虑多次打包的问题，仅是从开发体验来看，也会增加很大的研发成本。如果util是一个npm包，那么本地开发阶段如果需要修改util相关内容，我们就需要通过npm
          link等方案将util包加入到打包监听内容中，而发布的时候则需要增加一步。虽然整个流程上与传统前端开发抽取公共方法或公共组件库差不多，可设想如果平时开发的应用，任何一个可复用的内容都必须变成一个npm包，大家还会觉得没问题吗？显然npm包的方案不太合理。
        </p>\n<p>
          那util是否可以是一个子应用？这也不太合理，因为一旦抽离为子应用，方法互相调用便成为难题，集团和社区现有的微前端方案，对于子应用之间的互相调用，要么没有方案，要么从主应用中转，而一般来说，我们一定是希望代码长成下面这样：
        </p>\n<div class="syntax-highlighter_3YnAN">
          <pre
            style="display: block; overflow-x: auto; padding: 0.5em; color: rgb(51, 51, 51); background: rgb(248, 248, 248);"><code style="white-space: pre;"><span style="color: rgb(51, 51, 51); font-weight: bold;">import</span><span> { someUtil } </span><span style="color: rgb(51, 51, 51); font-weight: bold;">from</span><span> </span><span style="color: rgb(221, 17, 68);">'util'</span><span>;</span></code></pre>
          <div class="syntax-highlighter-copy_1eBR0"> 复制</div>
        </div>\n<p>
          最终，我们从阿里云consoleX框架的runtime思想中给出了解法。runtime原本是用于处理不同版本基础库，比如React，在运行时共存的问题。基于webpack
          external的理念，将不同基础库包裹在独立的闭包里，并在内存中管控起来，从而达到隔离共存的效果，及依赖提升。</p>\n<p>
          借助这个思路，在整个微前端管理后台中，我们增加了runtime类型的子应用，同时在普通子应用选择runtime库的时候，增加这个类型的子应用依赖关联。代码中类似三方库引用的方式，类似下面这样：
        </p>\n<div class="syntax-highlighter_3YnAN">
          <pre
            style="display: block; overflow-x: auto; padding: 0.5em; color: rgb(51, 51, 51); background: rgb(248, 248, 248);"><code style="white-space: pre;"><span style="color: rgb(51, 51, 51); font-weight: bold;">import</span><span> { someUtil } </span><span style="color: rgb(51, 51, 51); font-weight: bold;">from</span><span> </span><span style="color: rgb(221, 17, 68);">'editor-render-util'</span><span>;</span></code></pre>
          <div class="syntax-highlighter-copy_1eBR0"> 复制</div>
        </div>\n<p>
          子应用的构建中，cli会与管理后台交互，获取需要external的库列表，里面自然也就会包含runtime类型的子应用名称。而对于runtime子应用本身开发而言，由于cli拥有同时启动多个子应用的能力，因此和开发普通子应用没有区别，而如果是在父目录启动vs
          code，整体开发体感就类似在一个lerna的多包工程里开发一样。</p>\n</li>\n<li>\n<p>
          依赖管理<br>\n基于上面那个问题，自然依赖管理就接踵而至。而且不仅是公共依赖库带来的依赖复杂度，业务子应用之间的依赖早就存在。举例来说，渲染之前需要对方案进行保存，同时又可以只对选中的某一个模型做渲染，方案保存则会依赖场景基础数据提取能力。<br>\n<span
            class="box_1zuEB image_2R4eW"><img
              src="https://ata2-img.oss-cn-zhangjiakou.aliyuncs.com/e2e4841c7accc4b16704684971651d2e.jpg"
              alt="ppt2.jpg"></span></p>\n<p>
          如图所示，从原始需求的子应用出发，我们会得到3级依赖关系，而如果细化之后，可能层级会更深，甚至更可能是一个图结构，而并非树结构。</p>\n<div
          class="syntax-highlighter_3YnAN">
          <pre
            style="display: block; overflow-x: auto; padding: 0.5em; color: rgb(51, 51, 51); background: rgb(248, 248, 248);"><code style="white-space: pre;"><span>这让我们必须重新审视两个问题：\n</span><span></span><span style="color: rgb(153, 0, 115);">    1.</span><span> 后台如何配置主子应用关系？\n</span><span></span><span style="color: rgb(153, 0, 115);">    2.</span><span> 子应用何时加载？</span></code></pre>
          <div class="syntax-highlighter-copy_1eBR0"> 复制</div>
        </div>\n<p>和普通微前端场景区别在哪里呢？—— 子应用数量。</p>\n<p>
          编辑器场景中我们子应用的数量在200个的量级，随着业务拓展，这个数字还在不断上升。对于问题1来说，传统微前端后台我们的配置都是人工的，因为一般只会有一层，即主子应用关联，而当这个量级上升到200，同时还需要将200个子应用之间互相的依赖关系配置正确，这就不是人工能做完的了。对于问题2来说，编辑器纯业务代码量在80万的量级，这些插件并不是每个业务场景都会用到的，比如做衣柜的时候一般不会需要硬装相关的能力，而如果不分场景直接加载，这部分性能损耗将直接表现在应用启动阶段，秒开直接变成天方夜谭，甚至10秒能打开都是一个难题。
        </p>\n<p>
          解法上我们在cli构建中增加了依赖解析能力，同时管理后台增加了依赖管理能力。前者将单个子应用的依赖关系梳理清楚，后者则用来简化配置，让用户只需要关注上图中Level
          1的子应用配置即可，其余都通过依赖管理自动生成运行时子应用配置文件。加载问题则在下文展开。</p>\n</li>\n<li>\n<p>
          服务中心<br>\n当多子应用共存成为常态，传统微前端方案不必太重视的子应用间消息通信，成为了一个重大的课题。这就像后端服务化拆分之后，rpc框架成为必要的基础设施一样，微前端也需要一个类似的能力。但是在解法上，其实存在2种不同的策略。其一是pubsub模型，让子应用间自由传递；其二则是大部分微前端框架都比较推崇的，中心化管控型，即观察者模式。我们选择的也是第二种。在实现层面，我们基于自研的turbox响应式状态管理框架，通过统一状态中心调度，实现消息互通；基于中间件机制，完成了一些切面能力。这有点类似rpc框架中的config
          center的定位，因此我们称之为服务中心。</p>\n<p>
          同时，借助上文中的依赖提升能力，业务编码过程中，可以将服务中心库以类似普通npm包形式引入使用，运行时会自动提升为公共依赖，并且由多个子应用共享，因此天然的变成了一个共享的中心化运行时，而不需要在主应用框架中定制。这是我们与社区很多方案不同的地方。
        </p>\n<p>服务中心用于业务架构，它有明确的定位。我们认为服务中心应该承载的，是与微服务理念完全对标的能力。我们参考了星环的<a
            href="https://yuque.antfin.com/business-platform/business-model/tmuxm8"
            target="_blank">业务术语描述</a>，认为服务应当是提供某一个业务领域内，完成某一个业务流程的业务服务，即子应用注册到服务中心的能力应当是一个带业务属性的API。也正因如此，在上文的util库方案中，我们技术方案上不会引导用户通过服务中心的形式，去使用util方法，即使底层能力上是互通的。
        </p>\n</li>\n<li>\n<p>
          代码提示<br>\n在处理完2-4的问题之后，我们剩下了一个不愿面对的问题，那就是ts的代码提示断层。这个问题即使在webpack5的模块联盟解法中，暂时也没有太好办法。传统微前端场景中，对此类问题可以忽略，因为这个问题只有在多子应用之后，才会让日常开发变得麻烦。
        </p>\n<p>对此，我们落地中的解法是结合框架配置rc文件的声明、cli或vscode插件能力和管理后台配置。我们设计rc文件会包含以下结构：</p>\n<div
          class="syntax-highlighter_3YnAN">
          <pre
            style="display: block; overflow-x: auto; padding: 0.5em; color: rgb(51, 51, 51); background: rgb(248, 248, 248);"><code style="white-space: pre;"><span>{\n</span><span>    </span><span>"subAppName"</span><span>: </span><span style="color: rgb(221, 17, 68);">"renderSubApp"</span><span>,\n</span>    ...\n<span>    </span><span>"runtime"</span><span>: [</span><span style="color: rgb(221, 17, 68);">"utilRuntime"</span><span>, </span><span style="color: rgb(221, 17, 68);">"commonComponentsRuntime"</span><span>],\n</span><span>    </span><span>"dependencies"</span><span>: [</span><span style="color: rgb(221, 17, 68);">"pickUpSubApp"</span><span>, </span><span style="color: rgb(221, 17, 68);">"saveAndLoadSubApp"</span><span>]\n</span>}\n</code></pre>
          <div class="syntax-highlighter-copy_1eBR0"> 复制</div>
        </div>\n<p>
          这份配置交给用户本地自行添加，保存后，由cli或vscode插件对其进行解析，后台静默下载对应的d.ts文件后拼接到约定的目录中。对于runtime的场景，只需要将对应的ts模块声明引入即可达到代码提示效果。对于子应用依赖场景，拼接后的类型文件将会拓展到服务中心的类型库中，从而使得服务中心调用类似getApp方法的时候，入参字符串可枚举，返回类型也明确。
        </p>\n</li>\n<li>\n<p>
          发布流程管控<br>\n流程管控问题是面对大型团队时遇到的问题。对编辑器来说，整个大团队接近100人，其中阿里前端团队投入的人数有6人，剩下的是我们收购的合资公司同学。拿开篇我们提到的几个业务模块举例，渲染业务在实际落地时候有5个子应用，定制业务拆分了6个。如果发布流程不做管控，配置信息的合并将会成为每个业务负责人的痛点。虽然各自业务都可以独立部署和发布，但是对主应用而言，配置是同一份的，这时候就会被迫将发布时间点拉平，从而失去了独立部署带来的灵活性。
        </p>\n<p>
          因此，我们在管理后台中引入了几个关键点：业务身份、环境流转、业务组负责人机制和业务定制化灰度。这里管理后台的体系化建设过于复杂，由于篇幅的关系，具体实现不在本篇展开。
        </p>\n</li>\n</ol>\n<h3>前行之前的思考：编辑器是否真的那么特殊？</h3>\n<p>
      上面一节我们主要讨论的内容，本质上是多子应用场景出现后，业务逼着技术往前走的结果。当我们走完这些节点后，在新的领域里，我们看到了更多的可能性。但是，在正式进入新的领域之前，我们需要明确一些规则。就像是没有规矩不成方圆，探索未知之前明确一些边界，未必能走对，但至少能有方向。
    </p>\n<p>
      总体来说，我们需要讨论的是这一节标题里的问题，而从前文中应该能感觉得出来，我们团队认为编辑器的场景才是微前端未来的通用场景。所以，这里我们需要细化讨论几个有争议的问题。</p>\n
    <h4>什么是子应用 —— 子应用和组件的边界？</h4>\n<p>
      现阶段，对于使用微前端目的是解决多应用拆分问题的业务而言，子应用和组件的边界完全不是问题，因为在这样的场景里，绝大部分只有子应用。然而，虽然可能有些冒犯，但是这样的技术方案在我看来是没做到位的，或者是业务没有复杂到一定程度，暂时还不需要更高维度的抽象。
    </p>\n<p>
      即使是中后台场景，多子应用也必然是一个绝对的趋势。大型中后台应用随着业务的发展，一定会在某一时间点进行saas化。和商用saas系统的区别，仅在于是否有收费项目而已，从技术层面，必然是互通的。这个观点几乎在所有中后台系统中都可以看到身影。saas化从前端角度来说，主要目的还是将不同能力在合适的实际透出，在商用的场景，就是配合权限体系，将付费内容透出给用户，从而实现按次或按功能集使用软件服务。抽象来看，saas化对前端提出的要求是，能够将功能以点状能力打包，按一定规范组合业务流程，并基于规则透出。而单从能力而言，为什么一定至少是页面级的呢？举一个saas中后台常见的功能：交易下单。在我们自己的业务场景里，用户到门店出设计方案之前需要交定金，这时候会有加购下单的流程，但是还有一种业务场景，则是设计师直面用户，先出方案再下单，并且是在编辑器界面中直接加购下单。或许这个流程会让人觉得很特殊，那我再举个例子：如果你负责的业务需要发布ic的商品，你会自己做一个商品发布页，还是通过iframe把淘系的商品发布列表嵌入进来呢？被嵌入的商品发布列表你会称之为页面，还是组件呢？
    </p>\n<p>我们认为，组件或子应用的边界，不应该由框架决定，即</p>\n<div class="syntax-highlighter_3YnAN">
      <pre
        style="display: block; overflow-x: auto; padding: 0.5em; color: rgb(51, 51, 51); background: rgb(248, 248, 248);"><code style="white-space: pre;"><span>通用技术架构设计与业务技术选型应该区分来看。</span></code></pre>
      <div class="syntax-highlighter-copy_1eBR0"> 复制</div>
    </div>\n<p>
      微前端体系的技术方案应该做到的是，提供子应用加载的能力，并且解决好开发体验和用户体验的问题。业务技术选型则应该从业务架构角度去思考，子应用和组件在什么场景下使用更能够提升自己的开发效率。所以，一个业务能力应该被定义为子应用或是组件，应该有业务框架决定。于是，我们又找到了合适的参考：星环。
    </p>\n<p>
      在我们自己团队中，我们定义：<strong>一个子应用的最小颗粒度，应该是一个业务服务，它至少能够完成单个节点的业务活动能力闭环，并且可被应用于多个其他业务活动中，可以有明确的业务API。</strong>这个定位和我们上一节中提到的服务中心定位是完全一致的。同时根据实际场景，并不严格要求所有业务都拆到最细粒度构成子应用。无法完成业务闭环的，比如高度抽象的表格组件、通用的模型转换数学库等，我们将其以组件或公共包的形式，通过npm包进行依赖。从这个思路上看，我们认为并不需要额外定义微模块的概念，因为它并不会带来能力差异或补全，反而会增加概念和学习成本，如果某个业务场景上有更合理的定义还请指教。
    </p>\n<h4>应用间如何通信？</h4>\n<p>常规的主子应用间通信都是通过观察者完成的，包括上文我们提到的服务中心也是一样。但是实际场景来说，我们还需要另一个能力：消息。
    </p>\n<p>这里给一个实际场景来说明消息的重要性。在编辑器场景中我们需要加载一个设计方案，方法定义是<code>loadDesignCase(caseId: string):
        void</code>。同时，对于caseId这些元数据的获取，我们将其放在另一个子应用中。实际场景里，元数据会有不同类型，加载方案需要的caseId一般就在url上面，而另一些数据，比如用户的企业ID则需要带着用户态去服务端获取。于是就会出现下面这个时序图的差别。<br>\n<span
        class="box_1zuEB image_2R4eW"><img
          src="https://ata2-img.oss-cn-zhangjiakou.aliyuncs.com/185a549f02ab80575f594b11b5629fe9.jpg"
          alt="ppt3.jpg"></span></p>\n<p>
      在只有服务调用的情况下，A的服务注册会在元数据接口返回之后完成，而B如果基于服务调用，则需要等待接口的promise卡点结束，在消息监听的场景下则会是另一个景象。当然，这个例子也不是完全无法优化，比如A可以将服务注册分阶段完成，将caseId获取的接口在一开始注册完成，这样B也不需要等待promise卡点了。这也符合技术方案的设计逻辑，毕竟消息和服务调用本身底层能力就是可以互通的。只是从框架设计层面如果增加了消息的方案，对业务的使用上可以起到一定的诱导作用，从而让业务的技术方案更优。在atom的方案中，我们借助turbox响应式状态管理框架，天然的将服务和消息两者能力提供了出来，让子应用之间可以通过类似react
      hook的方式去编排逻辑。</p>\n<h3>新的领域里，微前端还能做到什么</h3>\n<p>
      经过上一节的思考，我们基本能确定，微前端领域里不应该将编辑器这种多子应用的场景特殊化。因此，我们团队继续前进之后，探索到了一些新的可能性。</p>\n<h4>移除主应用概念 ——
      主应用faas化</h4>\n<p>
      在子应用定义明确，并且多子应用成为常态之后，我们发现，主应用中所有的能力都可以拆分子应用或公共库完成。主应用在实际应用场景中，核心职责将会变成：子应用加载、菜单管理、权限管理、layout统一化等，能力普遍偏向于通用。因此，我们认为主应用定位的趋势将会是越来越单薄和偏框架型的。
    </p>\n<p>基于以上结论，我们对主应用的技术方案做了一次升级：主应用faas化。</p>\n<p><span class="box_1zuEB image_2R4eW"><img
          src="https://ata2-img.oss-cn-zhangjiakou.aliyuncs.com/2aa1ecccf757ab15b8812f0a47ae8c8d.jpg"
          alt="ppt4.jpg"></span></p>\n<p>
      从图中可以看出，主应用FAAS化之后，我们将业务拓展性进行了规范，一方面满足了业务的定制需求，另一方面，将原本集中式的主应用变成了一个轻量级的纯框架应用。这意味着：<strong>业务不需要感知主应用的存在。</strong>这直接带来两个明显的研发提效点：1.
      主应用创建自动化，成本归零；2. 基于整套研发体系，本地研发不在需要启动主应用，开发子应用与开发单体SPA体验一致。</p>\n<p>
      虽然目前大部分微前端框架都可以满足单体子应用独立运行，但那是基于单子应用完备的前提，对于多子应用成为常态的情况，只满足单体独立运行远远不够。此外，由于主应用创建成本的降低，并且轻量化，对于一些经常要纠结是否单拆一个主应用用的场景，变得不再重要。最后，整个标准化体系建立之后，我们正在与DEF后台考虑打通，将发布体系一并集成，从而彻底将主应用概念移除，业务只需要关心某个业务流程需要哪些子应用配合，以及如何发布配置即可。
    </p>\n<h4>服务监控 —— 深度性能优化与稳定性提升</h4>\n<p>
      从服务中心出发，在多子应用场景下，我们发现，所有的服务调用值得被管控起来。如果我们将服务的概念类比一下就会发现，这里存在着一个明显的基础设施：调用链管控。类比服务端就是人尽皆知的EagleEye。
    </p>\n<p>
      我们基于服务中心的框架设计，在中间件上增加了全链路traceId，打通了EagleEye的traceId，同时记录了不同子应用之间的服务调用耗时。因此，以编辑器场景为例，原本我们只能统计一个模型从左侧类目拖拽到画布并渲染的总体性能消耗，而现在我们可以精细地，将性能管控分为选中模型初始化、跟随移动、定位渲染三个细分步骤，并且最细粒度的分析性能损耗。更具有实际意义的是，基于我们对子应用的设定以及服务中心的设计，服务API的互相调用是标准化的，所以这些性能管控是可以通过框架方案解决的，不需要业务手动增加埋点。后续我们完成数据可视化之后，将可以对整体数据进行二次分析，从而更直观的去发现性能的瓶颈，而不是一句干巴巴的：拖个模型有点卡。此外，还能对服务的稳定性、成功率、统一错误兜底等做通用化的方案，来提高整个应用的稳定性。
    </p>\n<h3>关于未来的畅想</h3>\n<ul>\n<li>\n<p>模块依赖<br>\natom方案中的依赖提升部分，我们正在逐步与webpack5的module
          federation靠拢，这个方向让我们在技术上进一步模糊了子应用和公共模块的边界，将这两者彻底变成业务技术选型问题，甚至变成了打包方案和研发流程选择的问题。个人大胆预测，微前端未来会因为module
          federation的逐步成熟，让所有人都接受多子应用共存是常态的结论。</p>\n</li>\n<li>\n<p>
          与搭建体系的结合<br>\n基于上一个猜想，如果目前集团低代码和无代码搭建引擎拥抱了module federation，用它来加载一些自定义业务模块，那么以module
          federation为标准加载模式的微前端框架，将可以无缝的对接搭建能力。这样从整体架构上看，微前端完成saas化能力建设，搭建体系则完成paas层建设，两者之间的协议将会无缝衔接。
        </p>\n</li>\n</ul>\n<h3>最后</h3>\n<p>
      目前我们ihome前端团队还在继续往我们认为正确的方向摸索着，我们期待着那个未来逐步展现在面前，并为它的到来提前做好准备。</p>\n
  </div>  
</body>
</html>

